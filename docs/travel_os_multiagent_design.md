# Travel OS ë©€í‹°ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ ì„¤ê³„
## ì—¬í–‰ì˜ ëª¨ë“  ê²ƒì„ ê´€ì¥í•˜ëŠ” ìš´ì˜ì²´ì œ

> Travel OSëŠ” ë‹¨ìˆœí•œ ì±—ë´‡ì„ ë„˜ì–´ ì—¬í–‰ì˜ ëª¨ë“  ì¸¡ë©´ì„ ê´€ë¦¬í•˜ëŠ” **ì™„ì „í•œ ìš´ì˜ì²´ì œ**ì…ë‹ˆë‹¤. ë²¡í„°DBì™€ RAG ê¸°ë°˜ ê°œì¸í™”, ì‹¤ì‹œê°„ ë°ì´í„° ì—°ë™, GPS ìµœì í™”ë¥¼ í†µí•´ ì‚¬ìš©ìì—ê²Œ ë§ì¶¤í˜• ì—¬í–‰ ê²½í—˜ì„ ì œê³µí•©ë‹ˆë‹¤.

---

## ğŸ“š ëª©ì°¨

1. [ì‹œìŠ¤í…œ ê°œìš”](#1-ì‹œìŠ¤í…œ-ê°œìš”)
2. [í•µì‹¬ ì•„í‚¤í…ì²˜](#2-í•µì‹¬-ì•„í‚¤í…ì²˜)
3. [ì—ì´ì „íŠ¸ ìƒì„¸ ì„¤ê³„](#3-ì—ì´ì „íŠ¸-ìƒì„¸-ì„¤ê³„)
4. [ë°ì´í„° ë ˆì´ì–´](#4-ë°ì´í„°-ë ˆì´ì–´)
5. [ì›Œí¬í”Œë¡œìš° ì˜ˆì‹œ](#5-ì›Œí¬í”Œë¡œìš°-ì˜ˆì‹œ)
6. [í™•ì¥ ë¡œë“œë§µ](#6-í™•ì¥-ë¡œë“œë§µ)
7. [êµ¬í˜„ ê°€ì´ë“œ](#7-êµ¬í˜„-ê°€ì´ë“œ)

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ë¹„ì „

**Travel OS = ì—¬í–‰ì˜ ëª¨ë“  ê²ƒì„ ê´€ì¥í•˜ëŠ” ìš´ì˜ì²´ì œ**

```
ê¸°ì¡´ ì—¬í–‰ ì•± (í”Œë«í¼)     Travel OS (ìš´ì˜ì²´ì œ)
â”œâ”€ ë§›ì§‘ ì•±               â”œâ”€ ëª¨ë“  ì—¬í–‰ ê¸°ëŠ¥ í†µí•©
â”œâ”€ ìˆ™ì†Œ ì•±               â”œâ”€ ê°œì¸í™”ëœ AI íŒŒíŠ¸ë„ˆ
â”œâ”€ êµí†µ ì•±               â”œâ”€ ì‹¤ì‹œê°„ ìµœì í™”
â”œâ”€ ì¼ì • ì•±               â”œâ”€ ì»¨í…ìŠ¤íŠ¸ ìœ ì§€
â””â”€ ì§€ë„ ì•±               â””â”€ ë¬´í•œ í™•ì¥ ê°€ëŠ¥
```

### 1.2 í•µì‹¬ ì›ì¹™

1. **ì‚¬ìš©ì ì¤‘ì‹¬ ê°œì¸í™”**
   - ë²¡í„°DBì— ì‚¬ìš©ì ì„ í˜¸ë„ ì €ì¥
   - RAGë¡œ ê³¼ê±° ì—¬í–‰ ì´ë ¥ í™œìš©
   - ì‹¤ì‹œê°„ í•™ìŠµ

2. **ì™„ì „í•œ ììœ¨ì„±**
   - ì‚¬ìš©ìëŠ” ì˜ë„ë§Œ ì „ë‹¬
   - ì‹œìŠ¤í…œì´ ëª¨ë“  ê²ƒì„ ì²˜ë¦¬
   - í•„ìš”ì‹œì—ë§Œ í™•ì¸ ìš”ì²­

3. **í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°**
   - ìƒˆë¡œìš´ ì—ì´ì „íŠ¸ ì‰½ê²Œ ì¶”ê°€
   - ì™¸ë¶€ API ìœ ì—°í•˜ê²Œ ì—°ë™
   - ê¸°ëŠ¥ ë…ë¦½ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸

---

## 2. í•µì‹¬ ì•„í‚¤í…ì²˜

### 2.1 ì „ì²´ ì‹œìŠ¤í…œ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ì‚¬ìš©ì                                â”‚
â”‚                 (ìŒì„±/í…ìŠ¤íŠ¸/ìœ„ì¹˜ ì •ë³´)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ìºë¦­í„° í˜ë¥´ì†Œë‚˜ ë ˆì´ì–´ (ë¡œì»¬ LLM)                  â”‚
â”‚         ê¹Œì¹ ëƒ¥ì´ / ìˆœë‘¥ë©ë©ì´ / ì—‰ëš±ìˆ˜ë‹¬ (Qwen2.5)             â”‚
â”‚                                                             â”‚
â”‚  ì—­í• : ì…ì¶œë ¥ ë¼ìš°íŒ… + ìºë¦­í„° ì¼ê´€ì„± + ê°ì • í‘œí˜„               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Orchestrator (GPT-4 ê¸°ë°˜)                   â”‚
â”‚              "ì—¬í–‰ OSì˜ ì»¤ë„(Kernel)" - í•µì‹¬ ì¡°ìœ¨ì             â”‚
â”‚                                                             â”‚
â”‚  ì—­í• :                                                       â”‚
â”‚  - ì‚¬ìš©ì ì˜ë„ íŒŒì•…                                           â”‚
â”‚  - ì—ì´ì „íŠ¸ ì„ íƒ ë° ìˆœì„œ ê²°ì •                                  â”‚
â”‚  - ìƒíƒœ ê´€ë¦¬ (State Management)                             â”‚
â”‚  - ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬                                          â”‚
â”‚  - ê²°ê³¼ í†µí•© ë° ì‚¬ìš©ì ì‘ë‹µ ìƒì„±                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì „ë¬¸ ì—ì´ì „íŠ¸ ë ˆì´ì–´                         â”‚
â”‚              (ê° ì—ì´ì „íŠ¸ëŠ” ë…ë¦½ì ìœ¼ë¡œ ë™ì‘)                     â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Itinerary Planner â”‚  â”‚ Restaurant Finder â”‚               â”‚
â”‚  â”‚   ì¼ì • ê³„íš        â”‚  â”‚    ë§›ì§‘ ì¶”ì²œ       â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Accommodation    â”‚  â”‚ Transportation   â”‚                â”‚
â”‚  â”‚   ìˆ™ì†Œ ê²€ìƒ‰        â”‚  â”‚    êµí†µ ìµœì í™”     â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Route Optimizer  â”‚  â”‚ Weather Monitor  â”‚                â”‚
â”‚  â”‚   ê²½ë¡œ ìµœì í™”      â”‚  â”‚    ë‚ ì”¨ í™•ì¸       â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Crowd Analytics  â”‚  â”‚ Budget Manager   â”‚                â”‚
â”‚  â”‚   í˜¼ì¡ë„ ë¶„ì„      â”‚  â”‚    ì˜ˆì‚° ê´€ë¦¬       â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Real-time GPS    â”‚  â”‚ Event Searcher   â”‚                â”‚
â”‚  â”‚   GPS ë„¤ë¹„ê²Œì´ì…˜   â”‚  â”‚    ì´ë²¤íŠ¸ ê²€ìƒ‰     â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ë°ì´í„° ë ˆì´ì–´                             â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ Vector DB  â”‚  â”‚   Relational â”‚  â”‚   Cache    â”‚            â”‚
â”‚  â”‚  (Pinecone)â”‚  â”‚   DB (PostgreSQL)â”‚ â”‚  (Redis)   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ User Prefs â”‚  â”‚   Trip History â”‚  â”‚  Knowledge â”‚          â”‚
â”‚  â”‚  ì‚¬ìš©ì ì„ í˜¸ â”‚  â”‚  ì—¬í–‰ ê¸°ë¡   â”‚  â”‚   Base     â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì™¸ë¶€ API ë ˆì´ì–´                             â”‚
â”‚                                                             â”‚
â”‚  Google Maps â”‚ OpenWeather â”‚ Booking.com â”‚ ê³µê³µë°ì´í„°        â”‚
â”‚  Kakao Map   â”‚ ëŒ€ì¤‘êµí†µ API  â”‚ í•­ê³µì‚¬ API   â”‚ ë§›ì§‘ ë¦¬ë·° í¬ë¡¤ë§ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 State Schema

```python
from typing import TypedDict, Annotated, List, Dict
from operator import add

class TravelOSState(TypedDict):
    """Travel OS ì „ì²´ ìƒíƒœ"""
    
    # ì‚¬ìš©ì ì •ë³´
    user_id: str
    user_location: Dict  # {"lat": 37.5, "lng": 127.0}
    user_preferences: Dict  # ë²¡í„°DBì—ì„œ ë¡œë“œ
    
    # ëŒ€í™” ì»¨í…ìŠ¤íŠ¸
    messages: Annotated[List, add]
    user_intent: str  # "plan_trip", "find_restaurant", "modify_itinerary"
    
    # ì—¬í–‰ ì •ë³´
    trip_context: Dict
    destination: str
    dates: Dict  # {"start": "2024-01-01", "end": "2024-01-03"}
    budget: float
    num_people: int
    
    # ê° ì—ì´ì „íŠ¸ ê²°ê³¼
    itinerary: Dict
    restaurants: List[Dict]
    accommodations: List[Dict]
    transportation: Dict
    routes: List[Dict]
    weather: Dict
    events: List[Dict]
    crowd_info: Dict
    
    # ë©”íƒ€ ì •ë³´
    active_agents: List[str]
    completed_tasks: List[str]
    pending_tasks: List[str]
    requires_user_approval: bool
    
    # ìµœì¢… ì‘ë‹µ
    final_response: str
```

---

## 3. ì—ì´ì „íŠ¸ ìƒì„¸ ì„¤ê³„

### 3.1 Orchestrator (í•µì‹¬ ì¡°ìœ¨ì)

**ì—­í• :** Travel OSì˜ "ë‘ë‡Œ"

```python
class OrchestratorAgent:
    """
    ì‚¬ìš©ì ì˜ë„ë¥¼ íŒŒì•…í•˜ê³  ì ì ˆí•œ ì—ì´ì „íŠ¸ë“¤ì„ í˜¸ì¶œ
    """
    
    def __init__(self):
        self.llm = ChatOpenAI(model="gpt-4-turbo", temperature=0)
        self.intent_classifier = self.create_intent_classifier()
    
    async def execute(self, state: TravelOSState) -> TravelOSState:
        """ë©”ì¸ ë¡œì§"""
        
        # 1. ì˜ë„ íŒŒì•…
        intent = await self.classify_intent(state['messages'][-1])
        state['user_intent'] = intent
        
        # 2. í•„ìš”í•œ ì—ì´ì „íŠ¸ ê²°ì •
        required_agents = self.determine_agents(intent, state)
        
        # 3. ì—ì´ì „íŠ¸ ì‹¤í–‰ ê³„íš ìƒì„±
        execution_plan = self.create_execution_plan(required_agents, state)
        
        # 4. ìš°ì„ ìˆœìœ„/ì˜ì¡´ì„± ê¸°ë°˜ ìˆœì„œ ê²°ì •
        state['pending_tasks'] = execution_plan
        
        return state
    
    def classify_intent(self, message: str) -> str:
        """ì˜ë„ ë¶„ë¥˜"""
        intents = {
            "plan_new_trip": "ìƒˆë¡œìš´ ì—¬í–‰ ê³„íš",
            "find_restaurant": "ë§›ì§‘ ì°¾ê¸°",
            "find_accommodation": "ìˆ™ì†Œ ì°¾ê¸°",
            "optimize_route": "ê²½ë¡œ ìµœì í™”",
            "modify_itinerary": "ì¼ì • ìˆ˜ì •",
            "get_weather": "ë‚ ì”¨ í™•ì¸",
            "get_transportation": "êµí†µí¸ í™•ì¸",
            "check_crowd": "í˜¼ì¡ë„ í™•ì¸",
            "find_events": "ì´ë²¤íŠ¸ ì°¾ê¸°",
            "navigate": "ì‹¤ì‹œê°„ ë„¤ë¹„ê²Œì´ì…˜"
        }
        
        # GPT-4ë¡œ ë¶„ë¥˜
        prompt = f"""
        Classify the user's intent:
        Message: {message}
        
        Available intents:
        {json.dumps(intents, indent=2, ensure_ascii=False)}
        
        Output the intent key only.
        """
        
        response = self.llm.invoke(prompt)
        return response.content.strip()
    
    def determine_agents(self, intent: str, state: TravelOSState) -> List[str]:
        """ì˜ë„ì— ë”°ë¼ í•„ìš”í•œ ì—ì´ì „íŠ¸ ê²°ì •"""
        
        agent_map = {
            "plan_new_trip": [
                "itinerary_planner",
                "restaurant_finder",
                "accommodation_finder",
                "transportation_optimizer",
                "weather_monitor",
                "budget_manager"
            ],
            "find_restaurant": [
                "restaurant_finder",
                "crowd_analytics",  # í˜¼ì¡ë„ë„ í•¨ê»˜
                "route_optimizer"   # í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê²½ë¡œ
            ],
            "modify_itinerary": [
                "itinerary_planner",
                "route_optimizer",
                "budget_manager"
            ],
            "navigate": [
                "gps_navigator",
                "crowd_analytics",
                "weather_monitor"
            ]
        }
        
        return agent_map.get(intent, [])
    
    def create_execution_plan(self, agents: List[str], state: TravelOSState) -> List[Dict]:
        """ì‹¤í–‰ ê³„íš ìƒì„± (ì˜ì¡´ì„± ê³ ë ¤)"""
        
        # ì˜ì¡´ì„± ê·¸ë˜í”„
        dependencies = {
            "itinerary_planner": [],  # ë…ë¦½ì 
            "restaurant_finder": ["itinerary_planner"],  # ì¼ì • ë¨¼ì €
            "accommodation_finder": ["itinerary_planner"],
            "route_optimizer": ["restaurant_finder", "accommodation_finder"],
            "budget_manager": ["itinerary_planner", "restaurant_finder", "accommodation_finder"]
        }
        
        # ìœ„ìƒ ì •ë ¬ë¡œ ìˆœì„œ ê²°ì •
        plan = self.topological_sort(agents, dependencies)
        
        return plan
```

### 3.2 Itinerary Planner (ì¼ì • ê³„íš)

```python
class ItineraryPlannerAgent:
    """
    ì—¬í–‰ ì¼ì •ì„ ì§œëŠ” ì „ë¬¸ ì—ì´ì „íŠ¸
    RAG + LLM ê¸°ë°˜
    """
    
    def __init__(self):
        self.llm = ChatOpenAI(model="gpt-4", temperature=0.7)
        self.vector_store = self.setup_vector_store()
        self.retriever = self.vector_store.as_retriever(search_kwargs={"k": 10})
    
    async def execute(self, state: TravelOSState) -> TravelOSState:
        """ì¼ì • ìƒì„±"""
        
        # 1. RAG: ìœ ì‚¬í•œ ì—¬í–‰ ì¼ì • ê²€ìƒ‰
        query = f"{state['destination']} {state['dates']} ì—¬í–‰ ì¼ì •"
        similar_trips = await self.retriever.aget_relevant_documents(query)
        
        # 2. ì‚¬ìš©ì ì„ í˜¸ë„ ë°˜ì˜
        user_prefs = state['user_preferences']
        
        # 3. ë‚ ì”¨ ì •ë³´ ê³ ë ¤
        weather = state.get('weather', {})
        
        # 4. LLMìœ¼ë¡œ ì¼ì • ìƒì„±
        prompt = f"""
        Create a detailed travel itinerary:
        
        Destination: {state['destination']}
        Dates: {state['dates']['start']} to {state['dates']['end']}
        Budget: {state['budget']} KRW
        Number of people: {state['num_people']}
        
        User preferences:
        - Food: {user_prefs.get('food_preferences', [])}
        - Activities: {user_prefs.get('activities', [])}
        - Pace: {user_prefs.get('pace', 'moderate')}
        
        Similar trips reference:
        {self.format_similar_trips(similar_trips)}
        
        Weather forecast:
        {weather}
        
        Generate a day-by-day itinerary with:
        - Morning, Afternoon, Evening activities
        - Estimated time and cost for each
        - Travel time between locations
        - Alternatives for bad weather
        
        Format as structured JSON.
        """
        
        response = await self.llm.ainvoke(prompt)
        itinerary = json.loads(response.content)
        
        # 5. ìƒíƒœ ì—…ë°ì´íŠ¸
        state['itinerary'] = itinerary
        state['completed_tasks'].append('itinerary_planning')
        
        return state
    
    def setup_vector_store(self):
        """ë²¡í„° ìŠ¤í† ì–´ ì„¤ì • (ì—¬í–‰ ì§€ì‹ DB)"""
        from langchain.vectorstores import Pinecone
        from langchain.embeddings import OpenAIEmbeddings
        
        embeddings = OpenAIEmbeddings()
        
        # Pineconeì— ì €ì¥ëœ ì—¬í–‰ ì •ë³´ ë¡œë“œ
        vector_store = Pinecone.from_existing_index(
            index_name="travel-knowledge",
            embedding=embeddings
        )
        
        return vector_store
```

### 3.3 Restaurant Finder (ë§›ì§‘ ì¶”ì²œ)

```python
class RestaurantFinderAgent:
    """
    ë§›ì§‘ ì¶”ì²œ + ë¦¬ë·° ë¶„ì„ + ê°œì¸í™”
    """
    
    def __init__(self):
        self.llm = ChatOpenAI(model="gpt-4")
        self.vector_store = self.setup_restaurant_db()
        self.review_analyzer = ReviewAnalyzer()
    
    async def execute(self, state: TravelOSState) -> TravelOSState:
        """ë§›ì§‘ ê²€ìƒ‰ ë° ì¶”ì²œ"""
        
        # 1. ì¼ì •ì—ì„œ ì‹ì‚¬ ì‹œê°„/ìœ„ì¹˜ ì¶”ì¶œ
        meal_times = self.extract_meal_times(state['itinerary'])
        
        restaurants = []
        
        for meal in meal_times:
            # 2. ìœ„ì¹˜ ê¸°ë°˜ ê²€ìƒ‰
            nearby = await self.search_nearby_restaurants(
                location=meal['location'],
                cuisine=state['user_preferences'].get('food_preferences'),
                budget=self.calculate_meal_budget(state['budget'])
            )
            
            # 3. RAG: ë¦¬ë·° ê¸°ë°˜ í•„í„°ë§
            for restaurant in nearby:
                # ë²¡í„°DBì—ì„œ ë¦¬ë·° ê²€ìƒ‰
                reviews = await self.vector_store.similarity_search(
                    f"{restaurant['name']} ë¦¬ë·°"
                )
                
                # ë¦¬ë·° ê°ì„± ë¶„ì„
                sentiment = self.review_analyzer.analyze(reviews)
                
                restaurant['review_score'] = sentiment['score']
                restaurant['highlights'] = sentiment['highlights']
            
            # 4. ì¬ìˆœìœ„í™” (ê°œì¸í™” + ë¦¬ë·° + ìœ„ì¹˜)
            ranked = self.personalized_ranking(
                nearby,
                user_prefs=state['user_preferences']
            )
            
            restaurants.extend(ranked[:3])  # ìƒìœ„ 3ê°œ
        
        state['restaurants'] = restaurants
        state['completed_tasks'].append('restaurant_finding')
        
        return state
    
    async def search_nearby_restaurants(self, location, cuisine, budget):
        """ì‹¤ì œ API í˜¸ì¶œ"""
        # Google Places API / Kakao Local API
        results = await google_places_api.search(
            location=location,
            type='restaurant',
            keyword=cuisine,
            radius=1000
        )
        
        # ì˜ˆì‚° í•„í„°ë§
        filtered = [r for r in results if r['price_level'] <= budget]
        
        return filtered
    
    def personalized_ranking(self, restaurants, user_prefs):
        """ê°œì¸í™”ëœ ìˆœìœ„"""
        
        for r in restaurants:
            score = 0
            
            # ë¦¬ë·° ì ìˆ˜
            score += r['review_score'] * 0.4
            
            # ì‚¬ìš©ì ì„ í˜¸ ìŒì‹ ë§¤ì¹­
            cuisine_match = self.match_cuisine(r, user_prefs['food_preferences'])
            score += cuisine_match * 0.3
            
            # ê±°ë¦¬ ì ìˆ˜ (ê°€ê¹Œìš¸ìˆ˜ë¡ ë†’ìŒ)
            distance_score = 1 / (r['distance'] + 1)
            score += distance_score * 0.2
            
            # ê°€ê²© ì ì ˆì„±
            price_score = self.price_appropriateness(r['price_level'], user_prefs['budget_tier'])
            score += price_score * 0.1
            
            r['final_score'] = score
        
        return sorted(restaurants, key=lambda x: x['final_score'], reverse=True)
```

### 3.4 Route Optimizer (ê²½ë¡œ ìµœì í™”)

```python
class RouteOptimizerAgent:
    """
    ìµœë‹¨ ê²½ë¡œ + GPS ê¸°ë°˜ ì‹¤ì‹œê°„ ìµœì í™”
    TSP (Traveling Salesman Problem) ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
    """
    
    def __init__(self):
        self.maps_api = GoogleMapsAPI()
        self.tsp_solver = ORToolsTSP()
    
    async def execute(self, state: TravelOSState) -> TravelOSState:
        """ê²½ë¡œ ìµœì í™”"""
        
        # 1. ì¼ì •ì—ì„œ ëª¨ë“  POI ì¶”ì¶œ
        pois = self.extract_pois(state['itinerary'])
        
        # 2. ê±°ë¦¬ í–‰ë ¬ ìƒì„±
        distance_matrix = await self.get_distance_matrix(pois)
        
        # 3. TSP ë¬¸ì œ í’€ê¸°
        optimized_order = self.tsp_solver.solve(distance_matrix)
        
        # 4. ê° êµ¬ê°„ë³„ ìƒì„¸ ê²½ë¡œ
        routes = []
        for i in range(len(optimized_order) - 1):
            start = pois[optimized_order[i]]
            end = pois[optimized_order[i + 1]]
            
            route = await self.maps_api.get_directions(
                origin=start,
                destination=end,
                mode='transit',  # transit, driving, walking
                departure_time='now',
                alternatives=True  # ëŒ€ì•ˆ ê²½ë¡œë„
            )
            
            routes.append({
                'from': start,
                'to': end,
                'primary_route': route[0],
                'alternatives': route[1:],
                'estimated_time': route[0]['duration'],
                'distance': route[0]['distance']
            })
        
        # 5. ì‹¤ì‹œê°„ êµí†µ ì •ë³´ ë°˜ì˜
        for route in routes:
            traffic = await self.get_real_time_traffic(route['primary_route'])
            route['real_time_duration'] = traffic['duration_in_traffic']
            route['traffic_level'] = traffic['traffic_level']
        
        state['routes'] = routes
        state['completed_tasks'].append('route_optimization')
        
        return state
    
    async def get_distance_matrix(self, pois):
        """ëª¨ë“  POI ê°„ ê±°ë¦¬ í–‰ë ¬"""
        n = len(pois)
        matrix = [[0] * n for _ in range(n)]
        
        for i in range(n):
            for j in range(i + 1, n):
                distance = await self.maps_api.get_distance(pois[i], pois[j])
                matrix[i][j] = distance
                matrix[j][i] = distance
        
        return matrix
```

### 3.5 GPS Navigator (ì‹¤ì‹œê°„ ë„¤ë¹„ê²Œì´ì…˜)

```python
class GPSNavigatorAgent:
    """
    ì‹¤ì‹œê°„ GPS ê¸°ë°˜ ë„¤ë¹„ê²Œì´ì…˜
    ì‚¬ìš©ì ìœ„ì¹˜ ì¶”ì  + ë™ì  ê²½ë¡œ ì¬ê³„ì‚°
    """
    
    def __init__(self):
        self.maps_api = GoogleMapsAPI()
        self.location_tracker = LocationTracker()
    
    async def execute(self, state: TravelOSState) -> TravelOSState:
        """ì‹¤ì‹œê°„ ë„¤ë¹„ê²Œì´ì…˜"""
        
        # 1. í˜„ì¬ ìœ„ì¹˜
        current_location = state['user_location']
        
        # 2. ëª©ì ì§€
        destination = state['itinerary']['current_destination']
        
        # 3. ì‹¤ì‹œê°„ ê²½ë¡œ ê³„ì‚°
        route = await self.maps_api.get_directions(
            origin=current_location,
            destination=destination,
            mode='walking',  # ë˜ëŠ” 'transit', 'driving'
            departure_time='now'
        )
        
        # 4. ë‹¨ê³„ë³„ ì•ˆë‚´
        steps = route['legs'][0]['steps']
        
        navigation_guide = {
            'current_location': current_location,
            'destination': destination,
            'total_distance': route['legs'][0]['distance']['value'],
            'total_duration': route['legs'][0]['duration']['value'],
            'steps': [
                {
                    'instruction': step['html_instructions'],
                    'distance': step['distance']['text'],
                    'duration': step['duration']['text'],
                    'maneuver': step.get('maneuver', 'straight')
                }
                for step in steps
            ],
            'eta': self.calculate_eta(route)
        }
        
        # 5. ì£¼ë³€ ì •ë³´ (ë§›ì§‘, í™”ì¥ì‹¤, í¸ì˜ì  ë“±)
        nearby_amenities = await self.find_nearby_amenities(current_location)
        navigation_guide['nearby'] = nearby_amenities
        
        state['gps_navigation'] = navigation_guide
        
        return state
    
    async def track_and_update(self, state: TravelOSState):
        """ìœ„ì¹˜ ì¶”ì  ë° ê²½ë¡œ ì¬ê³„ì‚° (ë°±ê·¸ë¼ìš´ë“œ)"""
        
        while not state.get('navigation_complete'):
            # 1ì´ˆë§ˆë‹¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            await asyncio.sleep(1)
            
            new_location = await self.location_tracker.get_current_location()
            
            # ê²½ë¡œ ì´íƒˆ ê°ì§€
            if self.is_off_route(new_location, state['gps_navigation']):
                # ê²½ë¡œ ì¬ê³„ì‚°
                print("âš ï¸ ê²½ë¡œ ì´íƒˆ ê°ì§€! ì¬ê³„ì‚° ì¤‘...")
                await self.execute(state)
```

### 3.6 Weather Monitor (ë‚ ì”¨ ëª¨ë‹ˆí„°ë§)

```python
class WeatherMonitorAgent:
    """
    ë‚ ì”¨ ì˜ˆë³´ + ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ + ì¼ì • ì¡°ì • ì œì•ˆ
    """
    
    def __init__(self):
        self.weather_api = OpenWeatherMapAPI()
    
    async def execute(self, state: TravelOSState) -> TravelOSState:
        """ë‚ ì”¨ í™•ì¸ ë° ì˜í–¥ ë¶„ì„"""
        
        # 1. ì—¬í–‰ì§€ ë‚ ì”¨ ì˜ˆë³´
        destination = state['destination']
        dates = state['dates']
        
        forecast = await self.weather_api.get_forecast(
            location=destination,
            start_date=dates['start'],
            end_date=dates['end']
        )
        
        # 2. ì¼ì •ë³„ ë‚ ì”¨ ë§¤ì¹­
        itinerary = state['itinerary']
        
        for day in itinerary['days']:
            date = day['date']
            weather_for_day = forecast[date]
            
            # 3. ë‚ ì”¨ ì˜í–¥ ë¶„ì„
            impact = self.analyze_weather_impact(day['activities'], weather_for_day)
            
            day['weather'] = weather_for_day
            day['weather_impact'] = impact
            
            # 4. ëŒ€ì•ˆ ì œì•ˆ (ë¹„/ëˆˆ ì˜ˆë³´ ì‹œ)
            if impact['severity'] == 'high':
                alternatives = await self.suggest_alternatives(
                    day['activities'],
                    weather_for_day
                )
                day['alternative_activities'] = alternatives
        
        state['weather'] = forecast
        state['completed_tasks'].append('weather_monitoring')
        
        return state
    
    def analyze_weather_impact(self, activities, weather):
        """ë‚ ì”¨ê°€ í™œë™ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ ë¶„ì„"""
        
        impact = {'severity': 'low', 'warnings': []}
        
        # ì•¼ì™¸ í™œë™ ì²´í¬
        for activity in activities:
            if activity['type'] == 'outdoor':
                if weather['rain'] > 10:  # mm
                    impact['severity'] = 'high'
                    impact['warnings'].append(f"{activity['name']: ë¹„ ì˜ˆë³´ ({weather['rain']}mm)")
                
                if weather['temperature'] > 35 or weather['temperature'] < 0:
                    impact['severity'] = 'medium'
                    impact['warnings'].append(f"{activity['name']}: ê·¹í•œ ê¸°ì˜¨ ({weather['temperature']}Â°C)")
        
        return impact
```

### 3.7 Crowd Analytics (í˜¼ì¡ë„ ë¶„ì„)

```python
class CrowdAnalyticsAgent:
    """
    ì‹¤ì‹œê°„ í˜¼ì¡ë„ ë¶„ì„ + ì˜ˆì¸¡
    Google Popular Times + ê³µê³µë°ì´í„° í™œìš©
    """
    
    def __init__(self):
        self.google_places = GooglePlacesAPI()
        self.ml_model = CrowdPredictionModel()
    
    async def execute(self, state: TravelOSState) -> TravelOSState:
        """í˜¼ì¡ë„ ë¶„ì„"""
        
        pois = self.extract_pois(state['itinerary'])
        
        crowd_info = {}
        
        for poi in pois:
            # 1. Google Popular Times
            popular_times = await self.google_places.get_popular_times(poi['place_id'])
            
            # 2. ì‹¤ì‹œê°„ í˜¼ì¡ë„ (ìˆìœ¼ë©´)
            live_crowd = popular_times.get('live', None)
            
            # 3. ì˜ˆì¸¡ í˜¼ì¡ë„ (ML ëª¨ë¸)
            predicted_crowd = self.ml_model.predict(
                place_id=poi['place_id'],
                datetime=poi['visit_time'],
                day_of_week=poi['day_of_week'],
                weather=state['weather'].get(poi['date'], {})
            )
            
            crowd_info[poi['name']] = {
                'current': live_crowd,
                'predicted': predicted_crowd,
                'historical': popular_times['week'],
                'best_time_to_visit': self.find_best_time(popular_times),
                'recommendation': self.generate_recommendation(predicted_crowd)
            }
        
        state['crowd_info'] = crowd_info
        state['completed_tasks'].append('crowd_analytics')
        
        return state
    
    def generate_recommendation(self, crowd_level):
        """í˜¼ì¡ë„ ê¸°ë°˜ ì¶”ì²œ"""
        if crowd_level < 30:
            return "ì—¬ìœ ë¡œìš´ ì‹œê°„ì´ì—ìš”! ì²œì²œíˆ ë‘˜ëŸ¬ë³´ì„¸ìš”."
        elif crowd_level < 60:
            return "ì ë‹¹í•œ í˜¼ì¡ë„ì˜ˆìš”."
        else:
            return "âš ï¸ ë§¤ìš° í˜¼ì¡í•  ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤. ì‹œê°„ ì¡°ì •ì„ ê³ ë ¤í•˜ì„¸ìš”."
```

---

## 4. ë°ì´í„° ë ˆì´ì–´

### 4.1 Vector Database êµ¬ì¡°

```python
# Pinecone Vector DB ìŠ¤í‚¤ë§ˆ

# 1. User Preferences Vector
user_prefs_vectors = {
    "user_id": "u12345",
    "vector": [0.1, 0.5, ...],  # 768 dim
    "metadata": {
        "food_preferences": ["Italian", "Korean BBQ"],
        "activity_level": "moderate",
        "budget_tier": "medium",
        "travel_style": "cultural"
    }
}

# 2. Restaurant Reviews Vector
restaurant_vectors = {
    "restaurant_id": "r67890",
    "vector": [0.3, 0.2, ...],
    "metadata": {
        "name": "ë¶€ì‚° ë°€ë©´",
        "cuisine": "Korean",
        "price_level": 2,
        "rating": 4.5,
        "review_summary": "ë§›ìˆê³  ê°€ì„±ë¹„ ì¢‹ìŒ"
    }
}

# 3. Trip History Vector
trip_vectors = {
    "trip_id": "t11111",
    "vector": [0.7, 0.1, ...],
    "metadata": {
        "destination": "ë¶€ì‚°",
        "duration_days": 3,
        "satisfaction_score": 4.8,
        "itinerary": {...}
    }
}
```

### 4.2 PostgreSQL Schema

```sql
-- ì‚¬ìš©ì
CREATE TABLE users (
    user_id VARCHAR PRIMARY KEY,
    email VARCHAR,
    created_at TIMESTAMP,
    last_active TIMESTAMP
);

-- ì‚¬ìš©ì ìƒì„¸ í”„ë¡œí•„ (ì˜¤ëŠ˜ ì—…ë°ì´íŠ¸ë¨!)
CREATE TABLE personas (
    user_id VARCHAR PRIMARY KEY REFERENCES users(user_id),
    persona_like_food TEXT,   -- ì„ í˜¸ ìŒì‹
    persona_hate_food TEXT,   -- ê¸°í”¼ ìŒì‹
    persona_theme VARCHAR,    -- ì—¬í–‰ í…Œë§ˆ (íë§, ì•¡í‹°ë¹„í‹° ë“±)
    persona_like_region VARCHAR, -- ì„ í˜¸ ì§€ì—­
    persona_avoid_region VARCHAR, -- ê¸°í”¼ ì§€ì—­
    persona_transportation VARCHAR, -- ì´ë™ ìˆ˜ë‹¨
    persona_travel_budget INT,  -- 1ë°• ì˜ˆì‚°
    persona_accommodation_type VARCHAR, -- ìˆ™ì†Œ ìœ í˜•
    mbti_result VARCHAR,      -- ESTJ ë“±
    matched_character VARCHAR, -- cat, dog, otter
    updated_at TIMESTAMP
);

-- ì—¬í–‰ ì¼ì •
CREATE TABLE itineraries (
    itinerary_id SERIAL PRIMARY KEY,
    user_id VARCHAR REFERENCES users(user_id),
    destination VARCHAR,
    start_date DATE,
    end_date DATE,
    status VARCHAR, -- planning, confirmed, completed
    content JSONB  -- ì „ì²´ ì¼ì • JSON
);
```

---

## 5. ì›Œí¬í”Œë¡œìš° ì˜ˆì‹œ (ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤)

1. **ì‚¬ìš©ì**: "ì´ë²ˆ ì£¼ë§ì— ë¶€ì‚° 2ë°• 3ì¼ ì—¬í–‰ ê°€ê³  ì‹¶ì–´. ì˜ˆì‚°ì€ 30ë§Œì›ì´ê³  ë§›ìˆëŠ” ê±° ë§ì´ ë¨¹ê³  ì‹¶ì–´."
2. **Orchestrator**: ì˜ë„ íŒŒì•… â†’ `plan_new_trip`
3. **Itinerary Planner**: ë¶€ì‚° 2ë°• 3ì¼ ê¸°ë³¸ ì¼ì • ìƒì„± (ê´‘ì•ˆë¦¬, í•´ìš´ëŒ€, ë‚¨í¬ë™ ë“±)
4. **Restaurant Finder**: ì‹ì‚¬ ì‹œê°„ë§ˆë‹¤ ë§›ì§‘ ê²€ìƒ‰ (ë°€ë©´, ë¼ì§€êµ­ë°¥, íšŸì§‘) + ì‚¬ìš©ì ì„ í˜¸ ë°˜ì˜
5. **Accommodation Finder**: ì˜ˆì‚° ë²”ìœ„ ë‚´ ìˆ™ì†Œ ê²€ìƒ‰ (ê´‘ì•ˆë¦¬ ê·¼ì²˜ í˜¸í…”)
6. **Route Optimizer**: ë™ì„  ìµœì í™” (í•´ìš´ëŒ€ â†’ ê´‘ì•ˆë¦¬ ì´ë™ ê²½ë¡œ)
7. **Budget Manager**: ì´ ì˜ˆì‚° ê³„ì‚° ë° ê²€ì¦ (30ë§Œì› ì´ˆê³¼ ì—¬ë¶€ í™•ì¸)
8. **Final Response**: ì™„ì„±ëœ ì¼ì •í‘œ ì œì‹œ

---

## 6. í™•ì¥ ë¡œë“œë§µ

- **Phase 9**: ê°œì¸í™”ëœ ì¼ì • ìƒì„± (í˜„ì¬ ì§„í–‰ ì¤‘)
- **Phase 10**: ëŒ€ì‹œë³´ë“œ ì—°ë™
- **Phase 11**: RAG ê¸°ë°˜ ì§€ì‹ ê²€ìƒ‰
- **Phase 12**: ì‹¤ì‹œê°„ GPS ë„¤ë¹„ê²Œì´ì…˜ ëª¨ë“œ
- **Phase 13**: ìŒì„± ì¸í„°í˜ì´ìŠ¤ (STT/TTS) ì¶”ê°€
